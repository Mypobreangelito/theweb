---
/**
 * Slideshow.astro – Carousel infinito sin dependencias
 * Props:
 *  - images: Array<{ src: string, alt?: string, caption?: string }>
 *  - interval?: number (ms, default 4000)
 *  - autoplay?: boolean (default true)
 *  - pauseOnHover?: boolean (default true)
 *  - showDots?: boolean (default true)
 *  - showArrows?: boolean (default true)
 *
 * Uso:
 *  <Slideshow images={imgs} interval={5000} />
 */

export interface ImageItem {
  src: string;
  alt?: string;
  caption?: string;
}

const {
  images = [],
  interval = 4000,
  autoplay = true,
  pauseOnHover = true,
  showDots = true,
  showArrows = true,
} = Astro.props as {
  images: ImageItem[];
  interval?: number;
  autoplay?: boolean;
  pauseOnHover?: boolean;
  showDots?: boolean;
  showArrows?: boolean;
};

// BASE_URL asegura rutas correctas en GitHub Pages con `base: '/theweb/'`
const BASE = import.meta.env.BASE_URL || '/';

// Normaliza src para apuntar a /public/images/... con base
const normalized = images.map((it) => {
  const clean = it.src.startsWith('http')
    ? it.src
    : `${BASE}${it.src.replace(/^\/+/, '')}`;
  return { ...it, src: clean };
});

// Si hay menos de 1, no renderiza
const hasSlides = normalized.length > 0;
const slideCount = normalized.length;
const first = hasSlides ? normalized[0] : null;
const last  = hasSlides ? normalized[slideCount - 1] : null;

// Render list con clones [last, ...images, first] para loop suave
const renderList = hasSlides ? [last, ...normalized, first] : [];
---

{hasSlides ? (
  <section class="relative" aria-roledescription="carousel" aria-label="Galería de imágenes">
    <div
      class="overflow-hidden rounded-xl border border-gray-200"
      data-slider
      data-interval={interval}
      data-autoplay={autoplay ? 'true' : 'false'}
      data-hoverpause={pauseOnHover ? 'true' : 'false'}
    >
      <div class="flex touch-pan-y select-none" data-track style="transform: translateX(-100%);">
        {renderList.map((item, i) => (
          <figure class="relative shrink-0 w-full" style="aspect-ratio: 16/9;" aria-roledescription="slide">
            <img
              src={item!.src}
              alt={item!.alt ?? ''}
              loading="lazy"
              decoding="async"
              class="h-full w-full object-cover"
              draggable="false"
            />
            {item!.caption && (
              <figcaption class="absolute bottom-0 left-0 right-0 bg-black/40 text-white px-4 py-2 text-sm">
                {item!.caption}
              </figcaption>
            )}
          </figure>
        ))}
      </div>

      {showArrows && (
        <>
          <button class="absolute top-1/2 left-2 -translate-y-1/2 rounded-md bg-black/40 text-white px-3 py-2 focus:outline-none focus:ring"
                  data-prev aria-label="Anterior">‹</button>
          <button class="absolute top-1/2 right-2 -translate-y-1/2 rounded-md bg-black/40 text-white px-3 py-2 focus:outline-none focus:ring"
                  data-next aria-label="Siguiente">›</button>
        </>
      )}
    </div>

    {showDots && (
      <div class="mt-3 flex justify-center gap-2" data-dots role="tablist" aria-label="Selector de diapositiva">
        {normalized.map((_, i) => (
          <button class="h-2 w-2 rounded-full bg-gray-300 aria-[selected=true]:w-6 aria-[selected=true]:bg-gray-900 transition-all"
                  role="tab" data-dot={i} aria-selected={i === 0 ? 'true' : 'false'} aria-label={`Ir a la diapositiva ${i+1}`}></button>
        ))}
      </div>
    )}

    <p class="sr-only" aria-live="polite" data-status></p>
  </section>
) : (
  <p class="text-sm text-gray-500">No hay imágenes para mostrar.</p>
)}

<style is:global>
  /* Oculta scroll de la pista en navegadores que pudieran mostrarlo */
  [data-track] { will-change: transform; }
</style>

<script is:inline>
  // Slider sin framework
  const root = document.currentScript?.previousElementSibling?.closest('[data-slider]');
  if (!root) return;

  const track = root.querySelector('[data-track]');
  const prevBtn = root.querySelector('[data-prev]');
  const nextBtn = root.querySelector('[data-next]');
  const dotsWrap = root.parentElement.querySelector('[data-dots]');
  const status = root.parentElement.querySelector('[data-status]');

  const interval = Number(root.getAttribute('data-interval') || 4000);
  const autoplay = root.getAttribute('data-autoplay') === 'true';
  const hoverpause = root.getAttribute('data-hoverpause') === 'true';

  const slides = Array.from(track.children);
  const total = slides.length;      // incluye 2 clones
  const logicalTotal = total - 2;   // solo las diapositivas reales
  let index = 1;                    // arranca en la 1 real (tras el clon del final)
  let timer = null;
  let isAnimating = false;

  const setTransform = (idx, animate = true) => {
    if (animate) track.style.transition = 'transform 400ms ease';
    else track.style.transition = 'none';
    track.style.transform = `translateX(-${idx * 100}%)`;
  };

  const updateDots = () => {
    if (!dotsWrap) return;
    const realIdx = (index - 1 + logicalTotal) % logicalTotal; // 0..logicalTotal-1
    dotsWrap.querySelectorAll('[role="tab"]').forEach((b, i) => {
      b.setAttribute('aria-selected', i === realIdx ? 'true' : 'false');
    });
    if (status) status.textContent = `Diapositiva ${realIdx + 1} de ${logicalTotal}`;
  };

  const goTo = (idx) => {
    if (isAnimating) return;
    isAnimating = true;
    index = idx;
    setTransform(index, true);
  };

  const next = () => goTo(index + 1);
  const prev = () => goTo(index - 1);

  // Loop al terminar la transición (salto sin animación en bordes)
  track.addEventListener('transitionend', () => {
    if (index === total - 1) {       // si está en el clon del primero -> salta a la 1 real
      index = 1;
      setTransform(index, false);
    } else if (index === 0) {        // si está en el clon del último -> salta al último real
      index = total - 2;
      setTransform(index, false);
    }
    updateDots();
    requestAnimationFrame(() => { isAnimating = false; });
  });

  // Controles
  nextBtn?.addEventListener('click', next);
  prevBtn?.addEventListener('click', prev);

  // Dots
  dotsWrap?.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-dot]');
    if (!btn) return;
    const to = Number(btn.getAttribute('data-dot')); // 0..logicalTotal-1
    goTo(to + 1);
  });

  // Teclado
  root.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight') { e.preventDefault(); next(); }
    if (e.key === 'ArrowLeft')  { e.preventDefault(); prev(); }
  });
  root.setAttribute('tabindex', '0'); // foco para flechas

  // Autoplay + pausa en hover
  const start = () => {
    if (!autoplay) return;
    stop();
    timer = setInterval(next, interval);
  };
  const stop = () => { if (timer) { clearInterval(timer); timer = null; } };

  if (hoverpause) {
    root.addEventListener('mouseenter', stop);
    root.addEventListener('mouseleave', start);
    root.addEventListener('focusin', stop);
    root.addEventListener('focusout', start);
  }

  // Gestos táctiles (swipe)
  let touchStartX = 0, touchDX = 0, touching = false;
  root.addEventListener('touchstart', (e) => {
    touching = true;
    stop();
    track.style.transition = 'none';
    touchStartX = e.touches[0].clientX;
    touchDX = 0;
  }, { passive: true });

  root.addEventListener('touchmove', (e) => {
    if (!touching) return;
    touchDX = e.touches[0].clientX - touchStartX;
    const percent = touchDX / root.clientWidth * 100;
    track.style.transform = `translateX(calc(-${index * 100}% + ${percent}%))`;
  }, { passive: true });

  const endSwipe = () => {
    if (!touching) return;
    touching = false;
    const threshold = root.clientWidth * 0.15;
    track.style.transition = 'transform 300ms ease';
    if (Math.abs(touchDX) > threshold) {
      (touchDX < 0 ? next : prev)();
    } else {
      setTransform(index, true);
    }
    if (autoplay && !hoverpause) start(); // si no hay hoverpause, reanuda ya
    if (autoplay && hoverpause) setTimeout(start, 50);
  };
  root.addEventListener('touchend', endSwipe);
  root.addEventListener('touchcancel', endSwipe);

  // Init
  setTransform(index, false);
  updateDots();
  start();

  // Cleanup al cambiar de página (Astro islands no, pero por si acaso SPA)
  window.addEventListener('pagehide', stop);
</script>>
